{
  "$defs": {
    "ArrayMatch": {
      "additionalProperties": false,
      "properties": {
        "type": {
          "const": "array-match",
          "title": "Type",
          "type": "string"
        },
        "field": {
          "title": "Field",
          "type": "string"
        },
        "match": {
          "oneOf": [
            {
              "$ref": "#/$defs/ClauseStartsWith"
            },
            {
              "$ref": "#/$defs/ClauseEndsWith"
            },
            {
              "$ref": "#/$defs/ClauseContains"
            },
            {
              "$ref": "#/$defs/ClauseRegex"
            },
            {
              "$ref": "#/$defs/ClauseEquals"
            },
            {
              "$ref": "#/$defs/ClauseOr"
            },
            {
              "$ref": "#/$defs/ClauseAnd"
            }
          ],
          "title": "Match"
        }
      },
      "required": [
        "type",
        "field",
        "match"
      ],
      "title": "ArrayMatch",
      "type": "object"
    },
    "ClauseAnd": {
      "additionalProperties": false,
      "properties": {
        "and": {
          "items": {
            "oneOf": [
              {
                "$ref": "#/$defs/ClauseStartsWith"
              },
              {
                "$ref": "#/$defs/ClauseEndsWith"
              },
              {
                "$ref": "#/$defs/ClauseContains"
              },
              {
                "$ref": "#/$defs/ClauseRegex"
              },
              {
                "$ref": "#/$defs/ClauseEquals"
              },
              {
                "$ref": "#/$defs/ClauseOr"
              },
              {
                "$ref": "#/$defs/ClauseAnd"
              }
            ]
          },
          "title": "And",
          "type": "array"
        }
      },
      "required": [
        "and"
      ],
      "title": "ClauseAnd",
      "type": "object"
    },
    "ClauseContains": {
      "additionalProperties": false,
      "properties": {
        "contains": {
          "title": "Contains",
          "type": "string"
        }
      },
      "required": [
        "contains"
      ],
      "title": "ClauseContains",
      "type": "object"
    },
    "ClauseEndsWith": {
      "additionalProperties": false,
      "properties": {
        "ends_with": {
          "title": "Ends With",
          "type": "string"
        }
      },
      "required": [
        "ends_with"
      ],
      "title": "ClauseEndsWith",
      "type": "object"
    },
    "ClauseEquals": {
      "additionalProperties": false,
      "properties": {
        "equals": {
          "title": "Equals",
          "type": "string"
        }
      },
      "required": [
        "equals"
      ],
      "title": "ClauseEquals",
      "type": "object"
    },
    "ClauseOr": {
      "additionalProperties": false,
      "properties": {
        "or": {
          "items": {
            "oneOf": [
              {
                "$ref": "#/$defs/ClauseStartsWith"
              },
              {
                "$ref": "#/$defs/ClauseEndsWith"
              },
              {
                "$ref": "#/$defs/ClauseContains"
              },
              {
                "$ref": "#/$defs/ClauseRegex"
              },
              {
                "$ref": "#/$defs/ClauseEquals"
              },
              {
                "$ref": "#/$defs/ClauseOr"
              },
              {
                "$ref": "#/$defs/ClauseAnd"
              }
            ]
          },
          "title": "Or",
          "type": "array"
        }
      },
      "required": [
        "or"
      ],
      "title": "ClauseOr",
      "type": "object"
    },
    "ClauseRegex": {
      "additionalProperties": false,
      "properties": {
        "regex": {
          "format": "regex",
          "title": "Regex",
          "type": "string"
        }
      },
      "required": [
        "regex"
      ],
      "title": "ClauseRegex",
      "type": "object"
    },
    "ClauseStartsWith": {
      "additionalProperties": false,
      "properties": {
        "starts_with": {
          "title": "Starts With",
          "type": "string"
        }
      },
      "required": [
        "starts_with"
      ],
      "title": "ClauseStartsWith",
      "type": "object"
    },
    "ConditionalPrice": {
      "additionalProperties": false,
      "description": "Pricing together with constraints that define when those prices should be used.\n\nThe last price active price (price where the constraints are met) is used.",
      "properties": {
        "constraint": {
          "anyOf": [
            {
              "$ref": "#/$defs/StartDateConstraint"
            },
            {
              "$ref": "#/$defs/TimeOfDateConstraint"
            }
          ],
          "description": "Timestamp when this price starts, None means this price is always valid.",
          "title": "Constraint"
        },
        "prices": {
          "$ref": "#/$defs/ModelPrice",
          "description": "Prices for this condition."
        }
      },
      "required": [
        "prices"
      ],
      "title": "ConditionalPrice",
      "type": "object"
    },
    "ModelInfo": {
      "additionalProperties": false,
      "description": "Information about an LLM model",
      "properties": {
        "id": {
          "description": "Primary unique identifier for the model",
          "maxLength": 100,
          "pattern": "^\\S+$",
          "title": "Id",
          "type": "string"
        },
        "name": {
          "maxLength": 100,
          "type": "string",
          "description": "Name of the model",
          "title": "Name"
        },
        "description": {
          "maxLength": 1000,
          "type": "string",
          "description": "Description of the model",
          "title": "Description"
        },
        "match": {
          "description": "Boolean logic for matching this model to any identifier which could be used to reference the model in API requests",
          "oneOf": [
            {
              "$ref": "#/$defs/ClauseStartsWith"
            },
            {
              "$ref": "#/$defs/ClauseEndsWith"
            },
            {
              "$ref": "#/$defs/ClauseContains"
            },
            {
              "$ref": "#/$defs/ClauseRegex"
            },
            {
              "$ref": "#/$defs/ClauseEquals"
            },
            {
              "$ref": "#/$defs/ClauseOr"
            },
            {
              "$ref": "#/$defs/ClauseAnd"
            }
          ],
          "title": "Match"
        },
        "context_window": {
          "type": "integer",
          "description": "Maximum number of input tokens allowed for this model",
          "title": "Context Window"
        },
        "price_comments": {
          "maxLength": 1000,
          "type": "string",
          "description": "Comments about the pricing of the model, especially challenges in representing the provider's pricing model.",
          "title": "Price Comments"
        },
        "prices": {
          "anyOf": [
            {
              "$ref": "#/$defs/ModelPrice"
            },
            {
              "items": {
                "$ref": "#/$defs/ConditionalPrice"
              },
              "type": "array"
            }
          ],
          "description": "Set of prices for using this model.\n\nWhen multiple `ConditionalPrice`s are used, they are tried last to first to find a pricing model to use.\nE.g. later conditional prices take precedence over earlier ones.\n\nIf no conditional models match the conditions, the first one is used.",
          "title": "Prices"
        },
        "price_discrepancies": {
          "additionalProperties": true,
          "type": "object",
          "description": "List of price discrepancies based on external sources.",
          "title": "Price Discrepancies"
        },
        "prices_checked": {
          "format": "date",
          "type": "string",
          "description": "Date indicating when the prices were last checked for discrepancies.",
          "title": "Prices Checked"
        },
        "collapse": {
          "default": true,
          "description": "Flag indicating whether this price should be collapsed into other prices.",
          "title": "Collapse",
          "type": "boolean"
        },
        "deprecated": {
          "type": "boolean",
          "description": "Flag indicating this model is deprecated by the provider but still functional.",
          "title": "Deprecated"
        },
        "removed": {
          "default": false,
          "description": "Flag indicating this model has been removed and is no longer available. Excluded from data.json.",
          "title": "Removed",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "match",
        "prices"
      ],
      "title": "ModelInfo",
      "type": "object"
    },
    "ModelPrice": {
      "additionalProperties": false,
      "description": "Set of prices for using a model",
      "properties": {
        "input_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million uncached text input/prompt token",
          "title": "Input Mtok"
        },
        "cache_write_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million tokens written to the cache",
          "title": "Cache Write Mtok"
        },
        "cache_read_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million tokens read from the cache",
          "title": "Cache Read Mtok"
        },
        "output_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million output/completion tokens",
          "title": "Output Mtok"
        },
        "input_audio_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million audio input tokens",
          "title": "Input Audio Mtok"
        },
        "cache_audio_read_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million audio tokens read from the cache",
          "title": "Cache Audio Read Mtok"
        },
        "output_audio_mtok": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "$ref": "#/$defs/TieredPrices"
            }
          ],
          "description": "price in USD per million output audio tokens",
          "title": "Output Audio Mtok"
        },
        "requests_kcount": {
          "type": "number",
          "description": "price in USD per thousand requests",
          "title": "Requests Kcount"
        },
        "tool_use_kcount": {
          "additionalProperties": {
            "type": "number"
          },
          "propertyNames": {
            "enum": [
              "web_search",
              "file_search"
            ]
          },
          "type": "object",
          "description": "price in USD per thousand tool use requests, keyed by tool use unit",
          "title": "Tool Use Kcount"
        }
      },
      "title": "ModelPrice",
      "type": "object"
    },
    "StartDateConstraint": {
      "additionalProperties": false,
      "description": "Constraint that defines when this price starts, e.g. when a new price is introduced.",
      "properties": {
        "start_date": {
          "description": "Date when this price starts",
          "format": "date",
          "title": "Start Date",
          "type": "string"
        }
      },
      "required": [
        "start_date"
      ],
      "title": "StartDateConstraint",
      "type": "object"
    },
    "Tier": {
      "additionalProperties": false,
      "description": "Price tier",
      "properties": {
        "start": {
          "description": "Start of the tier",
          "title": "Start",
          "type": "integer"
        },
        "price": {
          "description": "Price for this tier",
          "title": "Price",
          "type": "number"
        }
      },
      "required": [
        "start",
        "price"
      ],
      "title": "Tier",
      "type": "object"
    },
    "TieredPrices": {
      "additionalProperties": false,
      "description": "Pricing model when the amount paid varies by number of tokens.\n\nUses threshold-based pricing where *input tokens* crossing a tier applies that rate to ALL tokens of this type.\nThis is the industry standard \"cliff\" model used by most providers (Anthropic, Google, OpenAI, etc.).\n\nExample: For a tier starting at 200K tokens:\n- Using 199,999 tokens: all tokens pay base rate\n- Using 200,001 tokens: all tokens pay tier rate (not just the tokens above 200K)",
      "properties": {
        "base": {
          "description": "Base price in USD per million tokens, e.g. price until the first tier.",
          "title": "Base",
          "type": "number"
        },
        "tiers": {
          "description": "Extra price tiers.",
          "items": {
            "$ref": "#/$defs/Tier"
          },
          "title": "Tiers",
          "type": "array"
        }
      },
      "required": [
        "base",
        "tiers"
      ],
      "title": "TieredPrices",
      "type": "object"
    },
    "TimeOfDateConstraint": {
      "additionalProperties": false,
      "description": "Constraint that defines a daily interval when a price applies, useful for off-peak pricing like deepseek.",
      "properties": {
        "start_time": {
          "description": "Start time of the interval.",
          "format": "time",
          "title": "Start Time",
          "type": "string"
        },
        "end_time": {
          "description": "End time of the interval.",
          "format": "time",
          "title": "End Time",
          "type": "string"
        }
      },
      "required": [
        "start_time",
        "end_time"
      ],
      "title": "TimeOfDateConstraint",
      "type": "object"
    },
    "UsageExtractor": {
      "additionalProperties": false,
      "description": "Logic for extracting usage information from a response.",
      "properties": {
        "api_flavor": {
          "default": "default",
          "description": "Name of the API flavor, only needed when a provider has multiple flavors, e.g. OpenAI has `chat` and `responses`.",
          "title": "Api Flavor",
          "type": "string"
        },
        "root": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/$defs/ArrayMatch"
                  }
                ]
              },
              "type": "array"
            }
          ],
          "description": "Path to the root of the usage information in the response, generally `usage`.",
          "title": "Root"
        },
        "model_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/$defs/ArrayMatch"
                  }
                ]
              },
              "type": "array"
            }
          ],
          "default": "model",
          "description": "Path to the model name in the response.\n\nAlmost all APIs return this in the 'model' field, hence the default value.",
          "title": "Model Path"
        },
        "mappings": {
          "description": "Mappings from used to build usage.",
          "items": {
            "$ref": "#/$defs/UsageExtractorMapping"
          },
          "title": "Mappings",
          "type": "array"
        }
      },
      "required": [
        "root",
        "mappings"
      ],
      "title": "UsageExtractor",
      "type": "object"
    },
    "UsageExtractorMapping": {
      "additionalProperties": false,
      "description": "Mappings from used to build usage.",
      "properties": {
        "path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/$defs/ArrayMatch"
                  }
                ]
              },
              "type": "array"
            }
          ],
          "description": "Path to the value to extract",
          "title": "Path"
        },
        "dest": {
          "anyOf": [
            {
              "enum": [
                "input_tokens",
                "cache_write_tokens",
                "cache_read_tokens",
                "output_tokens",
                "input_audio_tokens",
                "cache_audio_read_tokens",
                "output_audio_tokens"
              ],
              "type": "string"
            },
            {
              "enum": [
                "web_search",
                "file_search"
              ],
              "type": "string"
            }
          ],
          "description": "Destination field to store the extracted value.\n\nIf multiple mappings point to the same destination, the values are summed.",
          "title": "Dest"
        },
        "required": {
          "default": true,
          "description": "Whether the value is required to be present in the response",
          "title": "Required",
          "type": "boolean"
        }
      },
      "required": [
        "path",
        "dest"
      ],
      "title": "UsageExtractorMapping",
      "type": "object"
    }
  },
  "additionalProperties": false,
  "description": "Information about an LLM inference provider",
  "properties": {
    "id": {
      "description": "Unique identifier for the provider",
      "maxLength": 100,
      "pattern": "^\\S+$",
      "title": "Id",
      "type": "string"
    },
    "name": {
      "description": "Common name of the organization",
      "maxLength": 100,
      "title": "Name",
      "type": "string"
    },
    "pricing_urls": {
      "items": {
        "format": "uri",
        "maxLength": 2083,
        "minLength": 1,
        "type": "string"
      },
      "type": "array",
      "description": "Link to pricing page for the provider",
      "title": "Pricing Urls"
    },
    "api_pattern": {
      "description": "Pattern to identify provider via HTTP API URL.",
      "title": "Api Pattern",
      "type": "string"
    },
    "description": {
      "maxLength": 1000,
      "type": "string",
      "description": "Description of the provider",
      "title": "Description"
    },
    "price_comments": {
      "maxLength": 1000,
      "type": "string",
      "description": "Comments about the pricing of this provider's models, especially challenges in representing the provider's pricing model.",
      "title": "Price Comments"
    },
    "model_match": {
      "oneOf": [
        {
          "$ref": "#/$defs/ClauseStartsWith"
        },
        {
          "$ref": "#/$defs/ClauseEndsWith"
        },
        {
          "$ref": "#/$defs/ClauseContains"
        },
        {
          "$ref": "#/$defs/ClauseRegex"
        },
        {
          "$ref": "#/$defs/ClauseEquals"
        },
        {
          "$ref": "#/$defs/ClauseOr"
        },
        {
          "$ref": "#/$defs/ClauseAnd"
        }
      ],
      "description": "Logic to find a provider based on the model reference.",
      "title": "Model Match"
    },
    "provider_match": {
      "oneOf": [
        {
          "$ref": "#/$defs/ClauseStartsWith"
        },
        {
          "$ref": "#/$defs/ClauseEndsWith"
        },
        {
          "$ref": "#/$defs/ClauseContains"
        },
        {
          "$ref": "#/$defs/ClauseRegex"
        },
        {
          "$ref": "#/$defs/ClauseEquals"
        },
        {
          "$ref": "#/$defs/ClauseOr"
        },
        {
          "$ref": "#/$defs/ClauseAnd"
        }
      ],
      "description": "Logic to find a provider based on the provider identifier.",
      "title": "Provider Match"
    },
    "extractors": {
      "items": {
        "$ref": "#/$defs/UsageExtractor"
      },
      "type": "array",
      "description": "Logic to extract usage information from the provider's API responses.",
      "title": "Extractors"
    },
    "fallback_model_providers": {
      "items": {
        "type": "string"
      },
      "type": "array",
      "description": "List of provider identifiers to fallback to to get prices if this provider doesn't have a price.\n\nThis is used when one provider offers another provider's models, e.g. Google and AWS offer Anthropic models,\nAzure offers OpenAI models, etc.",
      "title": "Fallback Model Providers"
    },
    "models": {
      "description": "List of models supported by this provider",
      "items": {
        "$ref": "#/$defs/ModelInfo"
      },
      "title": "Models",
      "type": "array"
    }
  },
  "required": [
    "id",
    "name",
    "api_pattern",
    "models"
  ],
  "title": "Provider",
  "type": "object"
}
